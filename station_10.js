// Generated by LiveScript 1.2.0
var ref$, each, listsToObj, take, drop, reverse, first, ggl, styleName, zoomLevel, wtbl, dur, pie, rds, arc, svg, buildHeatSvg, svg_heatred, svg_heatblue, pieColor, buildPie, buildHeatMap, parse, run, lsfl, wait, flokay, move, color, flash, overlayGoog;
ref$ = require("prelude-ls"), each = ref$.each, listsToObj = ref$.listsToObj, take = ref$.take, drop = ref$.drop, reverse = ref$.reverse, first = ref$.first;
ggl = {};
ggl.margin = {
  top: 20,
  left: 20,
  right: 0,
  bottom: 10
};
ggl.rect_round = 2;
ggl.rect_width = 10;
ggl.rect_margin = 4;
ggl.w = 380 - ggl.margin.left - ggl.margin.right;
ggl.h = 150 - ggl.margin.top - ggl.margin.bottom;
ggl.stationsTsv = null;
ggl.cw = 0;
ggl.ch = 0;
ggl.crg = 180;
ggl.hdata = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];
ggl.wdata = ["ㄧ", "二", "三", "四", "五", "六", "日"];
ggl.data = {};
ggl.autoplay = false;
ggl.clrschm = "RdYlBu";
ggl.nclr = 9;
ggl.lsclrrd = reverse(take(~~(ggl.nclr / 2) + 1, colorbrewer[ggl.clrschm][ggl.nclr]));
ggl.lsclrbl = drop(~~(ggl.nclr / 2), colorbrewer[ggl.clrschm][ggl.nclr]);
ggl.cstnm = null;
ggl.mpw = 1200;
ggl.mph = 700;
ggl.mapOffset = 4000;
styleName = "paper";
zoomLevel = {
  20: 1128.497220,
  19: 2256.994440,
  18: 4513.988880,
  17: 9027.977761,
  16: 18055.955520,
  15: 36111.911040,
  14: 72223.822090,
  13: 144447.644200,
  12: 288895.288400,
  11: 577790.576700,
  10: 1155581.153000,
  9: 2311162.307000,
  8: 4622324.614000,
  7: 9244649.227000,
  6: 18489298.450000,
  5: 36978596.910000,
  4: 73957193.820000,
  3: 147914387.600000,
  2: 295828775.300000,
  1: 591657550.500000
};
wtbl = listsToObj([0, 1, 2, 3, 4, 5, 6], ggl.wdata);
dur = (new Date("May 09 2014 08:22:54") - new Date("Nov 27 2013 16:32:13")) / (1000 * 60);
pie = d3.layout.pie().sort(null).value(function(it){
  return it.value;
});
rds = 100;
arc = d3.svg.arc().outerRadius(rds - 30).innerRadius(rds - 34);
svg = d3.select("body").select(".donut").append("svg").attr("width", 400).attr("height", 200).append("g").attr("transform", "translate(100, 100)");
buildHeatSvg = function(){
  return d3.select("body").select(".heatmap").append("svg").attr("width", ggl.w + ggl.margin.left + ggl.margin.right).attr("height", ggl.h + ggl.margin.top + ggl.margin.bottom).append("g").attr("transform", "translate(" + ggl.margin.left + ", " + ggl.margin.top + ")");
};
svg_heatred = buildHeatSvg();
svg_heatblue = buildHeatSvg();
pieColor = function(it, i){
  return it.style({
    "fill": function(it, i){
      if (i === 0) {
        return "rgb(255, 255, 191)";
      } else if (i === 1) {
        return "rgb(240, 59, 32)";
      } else {
        return "rgb(67, 162, 202)";
      }
    }
  });
};
buildPie = function(uptime){
  var g;
  g = svg.selectAll(".arc").data(pie(uptime), function(it){
    return it.data.type;
  });
  g.enter().append("path").attr({
    "d": arc,
    "class": "arc"
  }).call(pieColor);
  return g.transition().duration(1000).attrTween("d", function(it){
    var interpolate;
    this._current = this._current || it;
    interpolate = d3.interpolate(this._current, it);
    this._current = interpolate(0);
    return function(t){
      return arc(interpolate(t));
    };
  });
};
buildHeatMap = function(_data, colorlist, name, svg){
  var rg, c, color, hhrc, hrc;
  rg = d3.max(_data, function(it){
    return it.value;
  });
  c = d3.scale.quantize().domain([0, rg]).range(colorlist);
  color = function(it){
    if (rg === 0) {
      return first(colorlist);
    } else {
      return c(it);
    }
  };
  hhrc = svg.selectAll(".high").data(_data).enter().append("rect").attr({
    "x": function(it, i){
      return it.hour * (ggl.rect_width + ggl.rect_margin) - ggl.rect_margin;
    },
    "y": function(it, i){
      return it.week * (ggl.rect_width + ggl.rect_margin) + (it.week >= 5 ? 5 : 0) - ggl.rect_margin;
    },
    "rx": ggl.rect_round,
    "ry": ggl.rect_round,
    "width": ggl.rect_width + ggl.rect_margin * 2,
    "height": ggl.rect_width + ggl.rect_margin * 2,
    "class": function(it){
      return "high high" + it.week + "_" + it.hour;
    }
  }).style({
    "fill": "rgba(0, 0, 0, 0.56)",
    "display": "none"
  });
  hrc = svg.selectAll(".heatreact").data(_data);
  hrc.enter().append("rect").attr({
    "x": function(it, i){
      return it.hour * (ggl.rect_width + ggl.rect_margin);
    },
    "y": function(it, i){
      return it.week * (ggl.rect_width + ggl.rect_margin) + (it.week >= 5 ? 5 : 0);
    },
    "rx": ggl.rect_round,
    "ry": ggl.rect_round,
    "width": ggl.rect_width,
    "height": ggl.rect_width,
    "class": "heatreact"
  }).style({
    "fill": function(it){
      return color(it.value);
    }
  }).on("mouseover", function(it){
    ggl.cw = it.week;
    ggl.ch = it.hour;
    return flash();
  });
  hrc.transition().style({
    "fill": function(it){
      return color(it.value);
    }
  });
  svg.selectAll(".xaxis").data(ggl.hdata).enter().append("text").attr({
    "x": function(it, i){
      return i * (ggl.rect_width + ggl.rect_margin) + ggl.rect_width / 2;
    },
    "y": 0,
    "class": "xaxis"
  }).style({
    "text-anchor": "middle"
  }).text(function(it, i){
    if ((i + 1) % 2 === 0) {
      return it;
    } else {
      return "";
    }
  });
  svg.selectAll(".yaxis").data(ggl.wdata).enter().append("text").attr({
    "x": -18,
    "y": function(it, i){
      return ggl.rect_width + i * (ggl.rect_width + ggl.rect_margin) + (i >= 5 ? 5 : 0);
    },
    "class": "yaxis"
  }).text(function(it){
    return it;
  });
  return d3.selectAll(".heat_station").text(name);
};
parse = function(json){
  var result, itm;
  result = [];
  for (itm in json) {
    result.push({
      "hour": itm.split("_")[1],
      "week": (itm.split("_")[0] - 1 + 7) % 7,
      "value": json[itm]
    });
  }
  return result;
};
run = function(){
  if (ggl.cstnm === null) {
    buildHeatMap(ggl.data.nobike["aggregate_nobike"], ggl.lsclrrd, "Total", svg_heatred);
    return buildHeatMap(ggl.data.nospace["aggregate_nospace"], ggl.lsclrbl, "Total", svg_heatblue);
  } else {
    buildHeatMap(ggl.data.nobike[ggl.cstnm], ggl.lsclrrd, ggl.cstnm, svg_heatred);
    return buildHeatMap(ggl.data.nospace[ggl.cstnm], ggl.lsclrbl, ggl.cstnm, svg_heatblue);
  }
};
lsfl = ["nobike", "nospace"];
wait = 0;
flokay = lsfl.length;
lsfl.map(function(it, j){
  ggl.data[it] = {};
  return d3.tsv("./week_hour_total/" + it + ".tsv", function(err, temp){
    --flokay;
    wait += temp.length;
    return temp.filter(function(row, i){
      var cell, results$ = [];
      --wait;
      ggl.data[it][row.stations] = [];
      for (cell in row) {
        if (cell !== "stations") {
          row[cell] = +row[cell];
          ggl.data[it][row.stations].push({
            "hour": +cell.split("_")[1],
            "week": +(cell.split("_")[0] - 1 + 7) % 7,
            "value": row[cell]
          });
        }
        if (wait === 0 && flokay === 0 && cell === "6_23") {
          results$.push(run());
        }
      }
      return results$;
    });
  });
});
move = function(){
  ++ggl.ch;
  if (ggl.ch >= 24) {
    ++ggl.cw;
    ggl.ch = 0;
  }
  if (ggl.cw >= 6) {
    ggl.ch = 0;
    ggl.cw = 0;
  }
  return flash();
};
color = d3.scale.quantize().domain([-ggl.crg, ggl.crg]).range(colorbrewer[ggl.clrschm][ggl.nclr]);
flash = function(){
  var tmpidx, l, nobike, nospace, good, ttl, nobike_p, nospace_p, good_p, up;
  d3.selectAll(".heat_weekday").text(wtbl[ggl.cw]);
  d3.selectAll(".heat_hour").text(ggl.ch);
  tmpidx = null;
  d3.selectAll(".vcircle").transition().duration(1000).style({
    "fill": function(it, i){
      if (tmpidx === null) {
        ggl.stationsTsv[i].nono.map(function(st, j){
          if (st.hour === ggl.ch && st.week === ggl.cw) {
            return tmpidx = j;
          }
        });
      }
      return color(ggl.stationsTsv[i].nono[tmpidx].value);
    }
  });
  d3.selectAll(".high").style({
    "display": "none"
  });
  d3.selectAll(".high" + ggl.cw + "_" + ggl.ch).style({
    "display": "inline"
  });
  if (ggl.data.nobike.aggregate_nobike[tmpidx] !== undefined) {
    l = ggl.data.nobike.aggregate_nobike.length;
    nobike = ggl.data.nobike.aggregate_nobike[tmpidx].value;
    nospace = ggl.data.nospace.aggregate_nospace[tmpidx].value;
    good = dur * l / (24 * 7) - nobike - nospace;
    ttl = nobike + nospace + good;
    nobike_p = nobike / ttl;
    nospace_p = nospace / ttl;
    good_p = good / ttl;
    d3.selectAll(".idx-good").text(~~(good_p * 100) + "%");
    d3.selectAll(".idx-nobike").text(~~(nobike_p * 1000) / 10 + "%");
    d3.selectAll(".idx-nospace").text(~~(nospace_p * 100) + "%");
    up = [
      {
        "type": "good",
        "value": good_p
      }, {
        "type": "nobike",
        "value": nobike_p
      }, {
        "type": "nospace",
        "value": nospace_p
      }
    ];
    return buildPie(up);
  }
};
overlayGoog = new google.maps.OverlayView();
d3.json("./mapstyle/" + styleName + ".json", function(err, mapStyle){
  var map, zoomTest, zoomText;
  mapStyle = new google.maps.StyledMapType(mapStyle, {
    name: styleName
  });
  d3.select('#map').style("width", ggl.mpw + "px").style("height", ggl.mph + "px").style("margin", "0px").style("padding", "0px");
  map = new google.maps.Map(d3.select('#map').node(), {
    zoom: 12,
    center: new google.maps.LatLng(25.043897602152036, 121.65124407043459),
    mapTypeControlOptions: {
      mapTypeId: [google.maps.MapTypeId.ROADMAP, 'map_style']
    }
  });
  zoomTest = function(zoom){
    if (zoom >= 15) {
      return 1;
    } else {
      return 0;
    }
  };
  zoomText = function(zoom){
    return d3.select(".gPrints").selectAll("text").transition().style({
      "opacity": zoomTest(zoom)
    });
  };
  google.maps.event.addListener(map, "bounds_changed", function(){
    var bounds, northEast, southWest;
    bounds = this.getBounds();
    northEast = bounds.getNorthEast();
    southWest = bounds.getSouthWest();
    return zoomText(this.zoom);
  });
  map.mapTypes.set('map_style', mapStyle);
  map.setMapTypeId('map_style');
  return d3.tsv("./stations.tsv", function(err, stationsTsv){
    ggl.stationsTsv = stationsTsv.filter(function(d, i){
      var i$, ref$, len$;
      ["lat", "lng", "n_space"].map(function(it){
        return d[it] = +d[it];
      });
      ["nospace", "nobike"].map(function(it){
        return d[it] = ggl.data[it][d.goodstationname];
      });
      d.nono = [];
      for (i$ = 0, len$ = (ref$ = (fn$())).length; i$ < len$; ++i$) {
        i = ref$[i$];
        d.nono[i] = {};
        d.nono[i].week = d.nospace[i].week;
        d.nono[i].hour = d.nospace[i].hour;
        d.nono[i].value = d.nospace[i].value > d.nobike[i].value
          ? d.nospace[i].value
          : -d.nobike[i].value;
      }
      return true;
      function fn$(){
        var i$, to$, results$ = [];
        for (i$ = 0, to$ = d.nospace.length - 1; i$ <= to$; ++i$) {
          results$.push(i$);
        }
        return results$;
      }
    });
    overlayGoog.onAdd = function(){
      var layer, svg, gPrints, gv;
      layer = d3.select(this.getPanes().overlayMouseTarget).append("div");
      svg = layer.append("svg");
      gPrints = svg.append("g").attr("class", "gPrints");
      svg.attr("width", ggl.mapOffset * 2).attr("height", ggl.mapOffset * 2).style("position", "absolute").style("top", -1 * ggl.mapOffset).style("left", -1 * ggl.mapOffset);
      gv = svg.append("g").attr("class", "gv");
      return overlayGoog.draw = function(){
        var overlayProjection, googleMapProjection, projecting, current_zoom, setcircle, settext, setclipPath, t, cp, b, voronoi, setvoronoi, pv, c;
        overlayProjection = this.getProjection();
        googleMapProjection = function(coordinates){
          var googleCoordinates, pixelCoordinates;
          googleCoordinates = new google.maps.LatLng(coordinates[1], coordinates[0]);
          pixelCoordinates = overlayProjection.fromLatLngToDivPixel(googleCoordinates);
          return [pixelCoordinates.x + ggl.mapOffset, pixelCoordinates.y + ggl.mapOffset];
        };
        projecting = d3.geo.path().projection(googleMapProjection);
        ggl.stationsTsv.filter(function(it){
          var coor;
          coor = googleMapProjection([it.lng, it.lat]);
          it.coorx = coor[0];
          it.coory = coor[1];
          return true;
        });
        current_zoom = this.map.zoom;
        setcircle = function(it){
          return it.attr({
            "cx": function(it){
              return it.coorx;
            },
            "cy": function(it){
              return it.coory;
            },
            "r": function(){
              return 3;
            },
            "class": "stationdots"
          }).style({
            "fill": "red"
          });
        };
        settext = function(it){
          return it.attr({
            "x": function(it){
              return it.coorx;
            },
            "y": function(it){
              return it.coory;
            }
          }).style({
            "opacity": zoomTest(current_zoom)
          });
        };
        setclipPath = function(it){
          return it.attr({
            "cx": function(it){
              return it.coorx;
            },
            "cy": function(it){
              return it.coory;
            },
            "r": function(){
              return zoomLevel[20 - current_zoom] / 1000000 * 3;
            }
          });
        };
        t = gPrints.selectAll("text").data(ggl.stationsTsv);
        t.enter().append("text").text(function(it){
          return it["station_name"];
        }).call(settext);
        t.call(settext);
        cp = gPrints.selectAll(".clipPath").data(ggl.stationsTsv);
        cp.selectAll("circle").call(setclipPath);
        cp.enter().append("clipPath").attr({
          "id": function(it, i){
            return "clip-" + i;
          },
          "class": "clipPath"
        }).append("circle").call(setclipPath);
        b = ggl.mapOffset / 2;
        voronoi = d3.geom.voronoi().clipExtent([[ggl.mapOffset - b, 0 + ggl.mapOffset - b], [ggl.mpw + ggl.mapOffset + b, ggl.mph + ggl.mapOffset + b]]).x(function(it){
          return it.coorx;
        }).y(function(it){
          return it.coory;
        });
        setvoronoi = function(it){
          return it.attr({
            "d": function(it){
              return "M" + it.join(",") + "Z";
            }
          }).style({
            "stroke": "white",
            "stroke-width": 2,
            "opacity": 0.7
          });
        };
        pv = gv.selectAll("path").data(voronoi(ggl.stationsTsv));
        pv.enter().append("path").call(setvoronoi).attr({
          "id": function(it, i){
            return "path-" + i;
          },
          "class": "vcircle",
          "clip-path": function(it, i){
            return "url(#clip-" + i + ")";
          }
        }).on("mousedown", function(it, i){
          ggl.cstnm = ggl.stationsTsv[i].goodstationname;
          return run();
        });
        pv.transition().call(setvoronoi);
        c = gPrints.selectAll(".stationdots").data(ggl.stationsTsv);
        c.transition().call(setcircle);
        return c.enter().append("circle").call(setcircle);
      };
    };
    return overlayGoog.setMap(map);
  });
});